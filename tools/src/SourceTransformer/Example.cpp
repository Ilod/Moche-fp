#ifdef _HAS_EXCEPTIONS
#undef _HAS_EXCEPTIONS
#endif
#define _HAS_EXCEPTIONS 0

#ifdef _ITERATOR_DEBUG_LEVEL
#undef _ITERATOR_DEBUG_LEVEL
#endif
#define _ITERATOR_DEBUG_LEVEL 0

#pragma warning(push)
#pragma warning(disable: 4100 4127 4702 4996)
#include "clang/Driver/Options.h"
#pragma warning(push)
#pragma warning(disable: 4146 4267 4244 4291 4389 4512 4800)
#include "clang/AST/AST.h"
#pragma warning(pop)
#include "clang/AST/ASTContext.h"
#include "clang/AST/ASTConsumer.h"
#pragma warning(push)
#pragma warning(disable: 4267)
#include "clang/AST/RecursiveASTVisitor.h"
#pragma warning(pop)
#include "clang/Frontend/ASTConsumers.h"
#pragma warning(push)
#pragma warning(disable: 4512)
#include "clang/Frontend/FrontendActions.h"
#pragma warning(pop)
#pragma warning(push)
#pragma warning(disable: 4800)
#include "clang/Frontend/CompilerInstance.h"
#pragma warning(pop)
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "clang/Rewrite/Core/Rewriter.h"
#pragma warning(push)
#pragma warning(disable: 4267)
#include "clang/AST/Attr.h"
#pragma warning(pop)
#include <sstream>
#pragma warning(pop)

using namespace std;
using namespace clang;
using namespace clang::driver;
using namespace clang::tooling;
using namespace llvm;

Rewriter rewriter;
int numFunctions = 0;

struct GeneratedFunctionState
{
    bool isDeclared : 1;
    bool isAutoGenerated : 1;
    bool hasBody : 1;
};

class Writer
{
public:
    virtual ~Writer() {}
    virtual const char* getFunctionName() const = 0;
    virtual const char* getReturnType() const { return "void"; }
    virtual const char* getParams() const { return ""; }
    virtual const char* getParamsTypes() const { return ""; }
    virtual bool isConst() const { return false; }
    virtual bool isStatic() const { return false; }
    string getSignature() const
    {
        ostringstream ss;
        ss << getFunctionName() << (isStatic() ? "static " : " ") << getReturnType() << " (" << getParamsTypes() << ") " << (isConst() ? "const " : "") << "__attribute((thiscall))";
        return ss.str();
    }
    string getDeclaration() const
    {
        ostringstream ss;
        ss << (isStatic() ? (isConst() ? "constexpr static " : "static ") : "") << "AUTOMATIC_REGENERATE " << getReturnType() << " " << getFunctionName() << "(" << getParams() << ")" << (isConst() && !isStatic() ? " const" : "") << (isStatic() ? "" : " override");
        return ss.str();
    }
    virtual string getBody(CXXRecordDecl* decl) const = 0;
};

class GetObjectClassRTTIWriter : public Writer
{
public:
    const char* getFunctionName() const override { return "objectClassRtti"; }
    bool isConst() const override { return true; }
    const char* getReturnType() const override { return "RTTIValue"; }
    string getBody(CXXRecordDecl* decl) const override
    {
        ostringstream ss;
        ss << "return crc(\"" << decl->getQualifiedNameAsString() << "\");";
        return ss.str();
    }
};

class GetClassRTTIWriter : public Writer
{
public:
    const char* getFunctionName() const override { return "classRtti"; }
    bool isConst() const override { return true; }
    bool isStatic() const override { return true; }
    const char* getReturnType() const override { return "RTTIValue"; }
    string getBody(CXXRecordDecl* decl) const override
    {
        ostringstream ss;
        ss << "return crc(\"" << decl->getQualifiedNameAsString() << "\");";
        return ss.str();
    }
};

class GetHasMemberWriter : public Writer
{
public:
    const char* getFunctionName() const override { return "hasMember"; }
    bool isConst() const override { return true; }
    const char* getReturnType() const override { return "bool"; }
    const char* getParams() const override { return "RTTIValue member"; }
    const char* getParamsTypes() const override { return "RTTIValue"; }
    string getBody(CXXRecordDecl* decl) const override
    {
        ostringstream ss;
        ss << "switch (member)\n{";
        bool atLeastOne = false;
        for (CXXRecordDecl::field_iterator iter = decl->field_begin(); iter != decl->field_end(); ++iter)
        {
            if (iter->getAccess() == clang::AS_public)
            {
                ss << "\ncase crc(\"" << iter->getNameAsString() << "\"):";
                atLeastOne = true;
            }
        }
        if (atLeastOne)
        {
            ss << "\n\treturn true;";
        }
        ss << "\ndefault:\n\treturn Super::hasMember(member);\n}";
        return ss.str();
    }
};

class GetHasMethodWriter : public Writer
{
public:
    const char* getFunctionName() const override { return "hasMethod"; }
    bool isConst() const override { return true; }
    const char* getReturnType() const override { return "bool"; }
    const char* getParams() const override { return "RTTIValue method"; }
    const char* getParamsTypes() const override { return "RTTIValue"; }
    string getBody(CXXRecordDecl* decl) const override
    {
        ostringstream ss;
        ss << "switch (method)\n{";
        bool atLeastOne = false;
        set<string> names;
        for (CXXRecordDecl::method_iterator iter = decl->method_begin(); iter != decl->method_end(); ++iter)
        {
            if (iter->getAccess() == clang::AS_public)
            {
                if (names.find(iter->getNameAsString()) == names.end())
                {
                    ss << "\ncase crc(\"" << iter->getNameAsString() << "\"):";
                    atLeastOne = true;
                    names.insert(iter->getNameAsString());
                }
            }
        }
        if (atLeastOne)
        {
            ss << "\n\treturn true;";
        }
        ss << "\ndefault:\n\treturn Super::hasMethod(method);\n}";
        return ss.str();
    }
};

class ExampleVisitor : public RecursiveASTVisitor<ExampleVisitor> {
private:
    ASTContext *astContext; // used for getting additional AST info
    CXXRecordDecl* runtimeObject;
    string runtimeObjectName;
    string regenerateAnnotationName;
    string toGenerateAnnotationName;
    typedef map<string, Writer*> FunctionMap;
    FunctionMap functions;
public:
    explicit ExampleVisitor(CompilerInstance *CI)
        : astContext(&(CI->getASTContext())) // initialize private members
        , runtimeObject(nullptr)
        , runtimeObjectName("RuntimeObject")
        , regenerateAnnotationName("automatic_generation")
        , toGenerateAnnotationName("automatic_generation_base(")
    {
        rewriter.setSourceMgr(astContext->getSourceManager(), astContext->getLangOpts());
        addFunction<GetObjectClassRTTIWriter>();
        addFunction<GetClassRTTIWriter>();
    }

    template<class T> void addFunction()
    {
        T* function = new T();
        functions[function->getSignature()] = function;
    }

    virtual ~ExampleVisitor()
    {
        for (FunctionMap::iterator iter = functions.begin(); iter != functions.end(); ++iter)
        {
            delete iter->second;
        }
        functions.clear();
    }

    bool VisitCXXRecordDecl(CXXRecordDecl* decl) 
    {
        if (!runtimeObject && decl->getQualifiedNameAsString() == runtimeObjectName)
        {
            runtimeObject = decl;
        }
        if (runtimeObject && decl->isCompleteDefinition() && (decl->getTagKind() == TTK_Class || decl->getTagKind() == TTK_Struct) && decl->isDerivedFrom(runtimeObject))
        {
            map<string, GeneratedFunctionState> states;
            bool full = true;
            bool containsBody = false;
            FunctionMap functionsMap = functions;
            for (CXXRecordDecl::method_iterator iter = decl->method_begin(); iter != decl->method_end(); ++iter)
            {
                if (iter->doesThisDeclarationHaveABody() || iter->getBody() != nullptr)
                {
                    ostringstream stringStream;
                    stringStream << iter->getNameAsString() << " " << iter->getType().getAsString();
                    string functionName = stringStream.str();
                    FunctionMap::iterator findFunction = functionsMap.find(functionName);
                    if (findFunction != functions.end())
                    {
                        clang::AttrVec& attrVec = iter->getAttrs();
                        for (unsigned int i = 0; i < attrVec.size(); ++i)
                        {
                            if (attrVec[i]->getKind() == clang::attr::Annotate)
                            {
                                AnnotateAttr* attr = static_cast<AnnotateAttr*>(attrVec[i]);
                                if (attr->getAnnotation().equals(regenerateAnnotationName))
                                {
                                    // TODO regenerate
                                    break;
                                }
                            }
                        }
                        functionsMap.erase(findFunction);
                    }
                }
                if (!iter->doesThisDeclarationHaveABody())
                {
                    full = false;
                    if (iter->getBody() != nullptr)
                    {
                        containsBody = true;
                    }
                }
            }
            if (full || containsBody)
            {
                for (FunctionMap::iterator iter = functionsMap.begin(); iter != functionsMap.end(); ++iter)
                {
                    // TODO generate
                }
            }
        }
        return true;
    }

    virtual bool VisitFunctionDecl(FunctionDecl *func) {
        numFunctions++;
        string funcName = func->getNameInfo().getName().getAsString();
        if (funcName == "do_math") {
            rewriter.ReplaceText(func->getLocation(), (unsigned int)(funcName.length()), "add5");
            errs() << "** Rewrote function def: " << funcName << "\n";
        }    
        return true;
    }

    virtual bool VisitStmt(Stmt *st) {
        if (CallExpr *call = dyn_cast<CallExpr>(st)) {
            rewriter.ReplaceText(call->getLocStart(), 7, "add5");
            errs() << "** Rewrote function call\n";
        }
        return true;
    }

/*
    virtual bool VisitReturnStmt(ReturnStmt *ret) {
        rewriter.ReplaceText(ret->getRetValue()->getLocStart(), 6, "val");
        errs() << "** Rewrote ReturnStmt\n";
        return true;
    }

    virtual bool VisitCallExpr(CallExpr *call) {
        rewriter.ReplaceText(call->getLocStart(), 7, "add5");
        errs() << "** Rewrote function call\n";
        return true;
    }
*/
};



class ExampleASTConsumer : public ASTConsumer {
private:
    ExampleVisitor *visitor; // doesn't have to be private

public:
    // override the constructor in order to pass CI
    explicit ExampleASTConsumer(CompilerInstance *CI)
        : visitor(new ExampleVisitor(CI)) // initialize the visitor
    { }

    // override this to call our ExampleVisitor on the entire source file
    virtual void HandleTranslationUnit(ASTContext &Context) {
        /* we can use ASTContext to get the TranslationUnitDecl, which is
             a single Decl that collectively represents the entire source file */
        visitor->TraverseDecl(Context.getTranslationUnitDecl());
    }

/*
    // override this to call our ExampleVisitor on each top-level Decl
    virtual bool HandleTopLevelDecl(DeclGroupRef DG) {
        // a DeclGroupRef may have multiple Decls, so we iterate through each one
        for (DeclGroupRef::iterator i = DG.begin(), e = DG.end(); i != e; i++) {
            Decl *D = *i;    
            visitor->TraverseDecl(D); // recursively visit each AST node in Decl "D"
        }
        return true;
    }
*/
};



class ExampleFrontendAction : public ASTFrontendAction {
public:
    virtual ASTConsumer *CreateASTConsumer(CompilerInstance &CI, StringRef) {
        return new ExampleASTConsumer(&CI); // pass CI pointer to ASTConsumer
    }
};



int main(int argc, const char **argv) {
    // parse the command-line args passed to your code
    CommonOptionsParser op(argc, argv, llvm::cl::GeneralCategory);        
    // create a new Clang Tool instance (a LibTooling environment)
    ClangTool Tool(op.getCompilations(), op.getSourcePathList());

    // run the Clang Tool, creating a new FrontendAction (explained below)
    int result = Tool.run(newFrontendActionFactory<ExampleFrontendAction>().get());

    errs() << "\nFound " << numFunctions << " functions.\n\n";
    // print out the rewritten source code ("rewriter" is a global var.)
    rewriter.getEditBuffer(rewriter.getSourceMgr().getMainFileID()).write(errs());
    return result;
}
